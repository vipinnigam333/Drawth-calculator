<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawth (by Vipin ke codes)</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Math.js for parsing mathematical expressions -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.js"></script>
    <style>
        /* Custom styles for a clean interface */
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent scrollbars from appearing */
        }
        canvas {
            cursor: grab;
            touch-action: none; /* Disable browser handling of touch events like panning */
        }
        canvas:active {
            cursor: grabbing;
        }
        /* Style for the function input list and sidebar */
        #sidebar {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 28rem; /* 448px - Increased width from 24rem */
        }
        #function-list-container {
            flex-grow: 1;
            overflow-y: auto;
        }
        .math-keyboard button {
            transition: background-color 0.15s ease-in-out;
            font-size: 0.9rem;
        }
        .function-input-group:hover .remove-btn,
        .function-input-group:hover .derivative-btn {
            opacity: 1;
        }
        .derivative-btn.active {
             background-color: #dbeafe; /* blue-100 */
             color: #2563eb; /* blue-600 */
        }
        .keyboard-tab {
            border-bottom: 2px solid transparent;
            margin-bottom: -1px; /* Overlap the container's border */
        }
        .keyboard-tab.active-tab {
            border-color: #3b82f6; /* blue-500 */
            color: #2563eb; /* blue-600 */
        }
        h1 > sub {
            font-weight: 500;
            font-size: 0.9rem;
            color: #6b7280;
        }
        #cursor-coords {
            position: absolute;
            display: none;
            padding: 4px 8px;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 0.8rem;
            pointer-events: none; /* Make it non-interactive */
            white-space: pre; /* Preserve newlines */
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            line-height: 1.4;
        }
    </style>
     <link rel="preconnect" href="https://fonts.googleapis.com">
     <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
     <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 flex h-screen w-screen">

    <!-- Sidebar for controls and function inputs -->
    <div id="sidebar" class="bg-white shadow-lg p-4 z-10">
        <div class="flex items-center mb-4 relative">
            <!-- Decorative SVG Graphic -->
            <svg class="absolute -top-3 -left-3 w-20 h-20 text-gray-200 opacity-60" fill="none" viewBox="0 0 100 100" stroke="currentColor" stroke-width="2">
                <path d="M0,50 Q25,10 50,50 T100,50" stroke-dasharray="5,5"/>
                <path d="M0,60 Q25,90 50,60 T100,60" stroke-dasharray="3,3"/>
            </svg>
            <h1 class="text-3xl font-bold text-gray-800 relative z-10">Drawth <sub>by Vipin ke codes</sub></h1>
        </div>
        <p class="text-sm text-gray-500 mb-4">Enter functions (e.g., `x^2`), inequalities (`y > sin(x)`), and plot derivatives using the f'(x) button.</p>

        <!-- Container for function input fields -->
        <div id="function-list-container" class="pr-2">
            <div id="function-list" class="space-y-3">
                <!-- Initial function input -->
                <div class="function-input-group flex items-center gap-2">
                     <input type="text" value="y = x^3 - x" class="function-input w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all">
                     <button class="derivative-btn opacity-0 text-gray-500 hover:bg-gray-200 rounded-md px-2 py-1 text-sm font-semibold transition-all" title="Plot Derivative">f'(x)</button>
                     <button class="remove-btn opacity-0 text-gray-400 hover:text-red-500 transition-opacity text-xl font-bold">&times;</button>
                </div>
                 <div class="function-input-group flex items-center gap-2">
                     <input type="text" value="y <= sin(x)" class="function-input w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all">
                     <button class="derivative-btn opacity-0 text-gray-500 hover:bg-gray-200 rounded-md px-2 py-1 text-sm font-semibold transition-all" title="Plot Derivative">f'(x)</button>
                     <button class="remove-btn opacity-0 text-gray-400 hover:text-red-500 transition-opacity text-xl font-bold">&times;</button>
                </div>
            </div>
        </div>
        
         <button id="add-function-btn" class="mt-4 w-full bg-blue-500 text-white py-2 px-4 rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition-colors">
            Add Function
        </button>
        <div id="error-message" class="mt-2 text-red-500 text-sm font-medium h-5"></div>
        
        <!-- Math Keyboard -->
        <div class="math-keyboard mt-4 pt-4 border-t">
            <div id="keyboard-tabs" class="flex border-b mb-2">
                <button data-panel="keyboard-main" class="keyboard-tab active-tab px-4 py-1 text-sm font-medium">Main</button>
                <button data-panel="keyboard-func" class="keyboard-tab text-gray-500 px-4 py-1 text-sm font-medium">Functions</button>
            </div>
            <div id="keyboard-main" class="grid grid-cols-5 gap-2">
                <button data-key="7" class="bg-gray-200 hover:bg-gray-300 rounded p-2">7</button>
                <button data-key="8" class="bg-gray-200 hover:bg-gray-300 rounded p-2">8</button>
                <button data-key="9" class="bg-gray-200 hover:bg-gray-300 rounded p-2">9</button>
                <button data-key="(" class="bg-gray-200 hover:bg-gray-300 rounded p-2">(</button>
                <button data-key=")" class="bg-gray-200 hover:bg-gray-300 rounded p-2">)</button>

                <button data-key="4" class="bg-gray-200 hover:bg-gray-300 rounded p-2">4</button>
                <button data-key="5" class="bg-gray-200 hover:bg-gray-300 rounded p-2">5</button>
                <button data-key="6" class="bg-gray-200 hover:bg-gray-300 rounded p-2">6</button>
                <button data-key="+" class="bg-gray-200 hover:bg-gray-300 rounded p-2">+</button>
                <button data-key="-" class="bg-gray-200 hover:bg-gray-300 rounded p-2">-</button>

                <button data-key="1" class="bg-gray-200 hover:bg-gray-300 rounded p-2">1</button>
                <button data-key="2" class="bg-gray-200 hover:bg-gray-300 rounded p-2">2</button>
                <button data-key="3" class="bg-gray-200 hover:bg-gray-300 rounded p-2">3</button>
                <button data-key="*" class="bg-gray-200 hover:bg-gray-300 rounded p-2">*</button>
                <button data-key="/" class="bg-gray-200 hover:bg-gray-300 rounded p-2">/</button>
                
                <button data-key="0" class="bg-gray-200 hover:bg-gray-300 rounded p-2">0</button>
                <button data-key="." class="bg-gray-200 hover:bg-gray-300 rounded p-2">.</button>
                <button data-key="^" class="bg-gray-200 hover:bg-gray-300 rounded p-2">^</button>
                <button data-key="x" class="bg-blue-200 hover:bg-blue-300 rounded p-2 font-mono">x</button>
                <button data-action="backspace" class="bg-red-200 hover:bg-red-300 rounded p-2">DEL</button>
                
                <button data-key="<" class="bg-gray-200 hover:bg-gray-300 rounded p-2">&lt;</button>
                <button data-key=">" class="bg-gray-200 hover:bg-gray-300 rounded p-2">&gt;</button>
                <button data-key="<=" class="bg-gray-200 hover:bg-gray-300 rounded p-2">&le;</button>
                <button data-key=">=" class="bg-gray-200 hover:bg-gray-300 rounded p-2">&ge;</button>
                <button data-key="y" class="bg-blue-200 hover:bg-blue-300 rounded p-2 font-mono">y</button>
            </div>
            <div id="keyboard-func" class="grid grid-cols-4 gap-2" style="display: none;">
                <button data-key="sin(" class="bg-gray-200 hover:bg-gray-300 rounded p-2">sin</button>
                <button data-key="cos(" class="bg-gray-200 hover:bg-gray-300 rounded p-2">cos</button>
                <button data-key="tan(" class="bg-gray-200 hover:bg-gray-300 rounded p-2">tan</button>
                <button data-key="pi" class="bg-gray-200 hover:bg-gray-300 rounded p-2">π</button>
                
                <button data-key="csc(" class="bg-gray-200 hover:bg-gray-300 rounded p-2">csc</button>
                <button data-key="sec(" class="bg-gray-200 hover:bg-gray-300 rounded p-2">sec</button>
                <button data-key="cot(" class="bg-gray-200 hover:bg-gray-300 rounded p-2">cot</button>
                <button data-key="e" class="bg-gray-200 hover:bg-gray-300 rounded p-2">e</button>

                <button data-key="arcsin(" class="bg-gray-200 hover:bg-gray-300 rounded p-2">sin⁻¹</button>
                <button data-key="arccos(" class="bg-gray-200 hover:bg-gray-300 rounded p-2">cos⁻¹</button>
                <button data-key="arctan(" class="bg-gray-200 hover:bg-gray-300 rounded p-2">tan⁻¹</button>
                <button data-key="abs(" class="bg-gray-200 hover:bg-gray-300 rounded p-2">|a|</button>

                <button data-key="ln(" class="bg-gray-200 hover:bg-gray-300 rounded p-2">ln</button>
                <button data-key="log(" class="bg-gray-200 hover:bg-gray-300 rounded p-2">log</button>
                <button data-key="sqrt(" class="bg-gray-200 hover:bg-gray-300 rounded p-2">√</button>
                <button data-key="!" class="bg-gray-200 hover:bg-gray-300 rounded p-2">n!</button>
            </div>
        </div>
    </div>

    <!-- Main area for the graph canvas -->
    <div class="flex-1 bg-white relative">
        <canvas id="graphCanvas"></canvas>
         <!-- Zoom Buttons -->
        <div class="absolute top-4 right-4 flex flex-col gap-2">
            <button id="zoom-in" class="w-10 h-10 bg-white border border-gray-300 rounded-md shadow-md flex items-center justify-center text-xl font-bold text-gray-600 hover:bg-gray-100">+</button>
            <button id="zoom-out" class="w-10 h-10 bg-white border border-gray-300 rounded-md shadow-md flex items-center justify-center text-xl font-bold text-gray-600 hover:bg-gray-100">-</button>
            <button id="reset-zoom" class="w-10 h-10 bg-white border border-gray-300 rounded-md shadow-md flex items-center justify-center text-xs font-bold text-gray-600 hover:bg-gray-100">RESET</button>
        </div>
        <!-- Cursor Coordinate Display -->
        <div id="cursor-coords" class="text-gray-700 font-mono"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('graphCanvas');
            const ctx = canvas.getContext('2d');
            const functionList = document.getElementById('function-list');
            const addFunctionBtn = document.getElementById('add-function-btn');
            const errorMessage = document.getElementById('error-message');
            const mathKeyboard = document.querySelector('.math-keyboard');
            const zoomInBtn = document.getElementById('zoom-in');
            const zoomOutBtn = document.getElementById('zoom-out');
            const resetZoomBtn = document.getElementById('reset-zoom');
            const keyboardTabs = document.getElementById('keyboard-tabs');
            const cursorCoords = document.getElementById('cursor-coords');

            // --- State Variables ---
            let scale = 50; // Pixels per unit
            let origin = { x: 0, y: 0 };
            let isDragging = false;
            let dragStart = { x: 0, y: 0 };
            const colors = ['#3b82f6', '#ef4444', '#22c55e', '#a855f7', '#f97316', '#14b8a6'];
            let functions = [];
            let lastFocusedInput = null;
            let lastMousePos = { x: 0, y: 0 }; // Track mouse for button zoom
            let debounceTimer;

            // --- Utility Functions ---
            const debounce = (func, delay) => {
                return function(...args) {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(() => {
                        func.apply(this, args);
                    }, delay);
                };
            };
            
            const toScreen = (x, y) => ({
                x: origin.x + x * scale,
                y: origin.y - y * scale
            });

            const toWorld = (x, y) => ({
                x: (x - origin.x) / scale,
                y: (y - origin.y) / -scale
            });

            const hexToRgba = (hex, alpha) => {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            };

            const parseInput = (input) => {
                const trimmed = input.trim();
                // Match y <= f(x) or x > f(y)
                const inequalityMatch = trimmed.match(/^(y|x)\s*(<=|>=|<|>)\s*(.*)$/i);
                if (inequalityMatch) {
                    return {
                        isInequality: true,
                        variable: inequalityMatch[1].toLowerCase(),
                        operator: inequalityMatch[2],
                        expression: inequalityMatch[3].trim(),
                        isStrict: inequalityMatch[2] === '<' || inequalityMatch[2] === '>'
                    };
                }

                // Match y = f(x) or x = f(y)
                const equalityMatch = trimmed.match(/^(y|x)\s*=\s*(.*)$/i);
                if (equalityMatch) {
                    return {
                        isInequality: false,
                        variable: equalityMatch[1].toLowerCase(),
                        operator: '=',
                        expression: equalityMatch[2].trim(),
                        isStrict: false
                    };
                }

                // Fallback for expressions without 'y =' part
                return {
                    isInequality: false,
                    variable: 'y',
                    operator: '=',
                    expression: trimmed,
                    isStrict: false
                };
            };


            // --- Canvas Setup and Drawing ---
            function resizeCanvas() {
                const parent = canvas.parentElement;
                canvas.width = parent.clientWidth;
                canvas.height = parent.clientHeight;
                origin = { x: canvas.width / 2, y: canvas.height / 2 };
                lastMousePos = { x: canvas.width / 2, y: canvas.height / 2 }; // Center initially
                draw();
            }

            function getGridStep(scale) {
                const minPixelsPerStep = 60;
                const worldDistance = minPixelsPerStep / scale;
                const exponent = Math.floor(Math.log10(worldDistance));
                const magnitude = Math.pow(10, exponent);
                const normalized = worldDistance / magnitude; 
                
                let step;
                if (normalized < 2) step = 2;
                else if (normalized < 5) step = 5;
                else step = 10;
                
                return step * magnitude;
            }

            function drawGridAndAxes() {
                const step = getGridStep(scale);
                const minorStep = step / 5;
                
                ctx.beginPath();
                ctx.strokeStyle = '#e5e7eb';
                ctx.lineWidth = 1;

                const worldBounds = {
                    xMin: toWorld(0, 0).x, xMax: toWorld(canvas.width, 0).x,
                    yMin: toWorld(0, canvas.height).y, yMax: toWorld(0, 0).y
                };

                for (let x = Math.floor(worldBounds.xMin / minorStep) * minorStep; x <= worldBounds.xMax; x += minorStep) {
                    const screenX = toScreen(x, 0).x;
                    ctx.moveTo(screenX, 0); ctx.lineTo(screenX, canvas.height);
                }
                for (let y = Math.floor(worldBounds.yMin / minorStep) * minorStep; y <= worldBounds.yMax; y += minorStep) {
                    const screenY = toScreen(0, y).y;
                    ctx.moveTo(0, screenY); ctx.lineTo(canvas.width, screenY);
                }
                ctx.stroke();

                ctx.beginPath();
                ctx.strokeStyle = '#d1d5db';
                ctx.lineWidth = 1;
                for (let x = Math.floor(worldBounds.xMin / step) * step; x <= worldBounds.xMax; x += step) {
                    const screenX = toScreen(x, 0).x;
                    ctx.moveTo(screenX, 0); ctx.lineTo(screenX, canvas.height);
                }
                for (let y = Math.floor(worldBounds.yMin / step) * step; y <= worldBounds.yMax; y += step) {
                    const screenY = toScreen(0, y).y;
                    ctx.moveTo(0, screenY); ctx.lineTo(canvas.width, screenY);
                }
                ctx.stroke();
                
                ctx.beginPath();
                ctx.strokeStyle = '#9ca3af';
                ctx.lineWidth = 2;
                ctx.moveTo(0, origin.y); ctx.lineTo(canvas.width, origin.y);
                ctx.moveTo(origin.x, 0); ctx.lineTo(origin.x, canvas.height);
                ctx.stroke();

                ctx.fillStyle = '#6b7280';
                ctx.font = '14px Inter';
                const labelPadding = 5;
                for (let x = Math.floor(worldBounds.xMin / step) * step; x <= worldBounds.xMax; x += step) {
                     if (Math.abs(x) < 1e-9) continue;
                    const label = Number(x.toPrecision(4));
                    ctx.fillText(label, toScreen(x, 0).x + labelPadding, origin.y - labelPadding);
                }
                for (let y = Math.floor(worldBounds.yMin / step) * step; y <= worldBounds.yMax; y += step) {
                    if (Math.abs(y) < 1e-9) continue;
                    const label = Number(y.toPrecision(4));
                    ctx.fillText(label, origin.x + labelPadding, toScreen(0, y).y - labelPadding);
                }
                 ctx.fillText('0', origin.x + labelPadding, origin.y - labelPadding);
            }

            function plot(parsed, color, isDerivative = false) {
                try {
                    let finalExpression = parsed.expression;
                    if (isDerivative) {
                         // Can't take derivative of an inequality boundary.
                        if(parsed.isInequality) return true; 
                        // Correctly determine the variable to differentiate with respect to.
                        const derivativeOf = parsed.variable === 'y' ? 'x' : 'y';
                        finalExpression = math.derivative(parsed.expression, derivativeOf).toString();
                    }

                    const node = math.parse(finalExpression);
                    const code = node.compile();
                    
                    // --- 1. Draw shaded area for inequalities ---
                    if (parsed.isInequality && !isDerivative) {
                        ctx.fillStyle = hexToRgba(color, 0.25);
                        if (parsed.variable === 'y') {
                            for (let sx = 0; sx < canvas.width; sx++) {
                                const wx = toWorld(sx, 0).x;
                                try {
                                    const wy_boundary = code.evaluate({ x: wx });
                                    if (typeof wy_boundary !== 'number' || !isFinite(wy_boundary)) continue;
                                    const sy_boundary = toScreen(wx, wy_boundary).y;
                                    if (parsed.operator === '>' || parsed.operator === '>=') ctx.fillRect(sx, 0, 1, sy_boundary);
                                    else ctx.fillRect(sx, sy_boundary, 1, canvas.height - sy_boundary);
                                } catch (e) { /* Ignore */ }
                            }
                        } else {
                             for (let sy = 0; sy < canvas.height; sy++) {
                                const wy = toWorld(0, sy).y;
                                try {
                                    const wx_boundary = code.evaluate({ y: wy });
                                    if (typeof wx_boundary !== 'number' || !isFinite(wx_boundary)) continue;
                                    const sx_boundary = toScreen(wx_boundary, wy).x;
                                    if (parsed.operator === '>' || parsed.operator === '>=') ctx.fillRect(sx_boundary, sy, canvas.width - sx_boundary, 1);
                                    else ctx.fillRect(0, sy, sx_boundary, 1);
                                } catch (e) { /* Ignore */ }
                            }
                        }
                    }

                    // --- 2. Draw the boundary line ---
                    ctx.beginPath();
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2.5;
                    
                    // Use dashed line for strict inequalities OR for derivatives
                    if (parsed.isStrict || isDerivative) {
                        ctx.setLineDash([8, 6]);
                    }

                    const worldBounds = {
                        xMin: toWorld(0, 0).x, xMax: toWorld(canvas.width, 0).x,
                        yMin: toWorld(0, canvas.height).y, yMax: toWorld(0, 0).y
                    };
                    const step = 1 / scale;
                    let firstPoint = true;
                    
                    if (parsed.variable === 'y') {
                        for (let x = worldBounds.xMin; x <= worldBounds.xMax; x += step) {
                            try {
                                const y = code.evaluate({ x: x });
                                if (typeof y === 'number' && isFinite(y)) {
                                    const screenCoords = toScreen(x, y);
                                    if (firstPoint) { ctx.moveTo(screenCoords.x, screenCoords.y); firstPoint = false; } 
                                    else { ctx.lineTo(screenCoords.x, screenCoords.y); }
                                } else { firstPoint = true; }
                            } catch (e) { firstPoint = true; }
                        }
                    } else { // variable is 'x'
                        for (let y = worldBounds.yMin; y <= worldBounds.yMax; y += step) {
                            try {
                                const x = code.evaluate({ y: y });
                                if (typeof x === 'number' && isFinite(x)) {
                                    const screenCoords = toScreen(x, y);
                                    if (firstPoint) { ctx.moveTo(screenCoords.x, screenCoords.y); firstPoint = false; } 
                                    else { ctx.lineTo(screenCoords.x, screenCoords.y); }
                                } else { firstPoint = true; }
                            } catch (e) { firstPoint = true; }
                        }
                    }

                    ctx.stroke();
                    ctx.setLineDash([]); // Reset for other elements
                    return true;

                } catch (err) {
                    errorMessage.textContent = err.message.split(' (')[0];
                    return false;
                }
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                drawGridAndAxes();
                let hasError = false;
                functions.forEach(func => {
                    if (func.expression && func.expression.trim() !== '') {
                        const parsed = parseInput(func.expression);
                         if (!parsed.expression) return;
                        if (!plot(parsed, func.color)) hasError = true;
                        
                        // Plot derivative if enabled
                        if(func.showDerivative) {
                            if (!plot(parsed, func.color, true)) hasError = true;
                        }
                    }
                });
                if (!hasError) errorMessage.textContent = '';
                ctx.restore();
            }
            
            const debouncedDraw = debounce(draw, 250);

            // --- Event Handlers ---
            function handleMouseDown(e) {
                isDragging = true;
                dragStart.x = e.clientX;
                dragStart.y = e.clientY;
                canvas.style.cursor = 'grabbing';
            }

            function handleMouseMove(e) {
                const rect = canvas.getBoundingClientRect();
                lastMousePos.x = e.clientX - rect.left;
                lastMousePos.y = e.clientY - rect.top;

                if (isDragging) {
                    const dx = e.clientX - dragStart.x;
                    const dy = e.clientY - dragStart.y;
                    origin.x += dx;
                    origin.y += dy;
                    dragStart.x = e.clientX;
                    dragStart.y = e.clientY;
                    draw();
                } else {
                    updateCursorDisplay();
                }
            }

            function handleMouseUp() {
                isDragging = false;
                canvas.style.cursor = 'grab';
            }

            function updateCursorDisplay() {
                const { x: wx, y: wy } = toWorld(lastMousePos.x, lastMousePos.y);
                cursorCoords.style.left = `${lastMousePos.x + 15}px`;
                cursorCoords.style.top = `${lastMousePos.y + 15}px`;

                let activeRegions = [];
                functions.forEach(func => {
                    const parsed = parseInput(func.expression);
                    if (parsed.isInequality && parsed.expression) {
                         try {
                            const node = math.parse(parsed.expression);
                            const code = node.compile();
                            let boundaryVal, cursorVal;
                            
                            if (parsed.variable === 'y') {
                                boundaryVal = code.evaluate({ x: wx });
                                cursorVal = wy;
                            } else {
                                boundaryVal = code.evaluate({ y: wy });
                                cursorVal = wx;
                            }

                            if (typeof boundaryVal !== 'number' || !isFinite(boundaryVal)) return;

                            let satisfied = false;
                            switch (parsed.operator) {
                                case '>': satisfied = cursorVal > boundaryVal; break;
                                case '>=': satisfied = cursorVal >= boundaryVal; break;
                                case '<': satisfied = cursorVal < boundaryVal; break;
                                case '<=': satisfied = cursorVal <= boundaryVal; break;
                            }
                            if (satisfied) {
                                activeRegions.push({ text: func.expression, color: func.color });
                            }
                        } catch (err) { /* Ignore */ }
                    }
                });

                let content = `(${wx.toFixed(2)}, ${wy.toFixed(2)})`;
                activeRegions.forEach(region => {
                    content += `\n<span style="color:${region.color};">&#9632;</span> ${region.text}`;
                });
                cursorCoords.innerHTML = content;
            }

            function applyZoom(zoomFactor, pivotX, pivotY) {
                const worldBeforeZoom = toWorld(pivotX, pivotY);
                scale *= zoomFactor;
                const worldAfterZoom = toWorld(pivotX, pivotY);
                origin.x += (worldAfterZoom.x - worldBeforeZoom.x) * scale;
                origin.y += (worldAfterZoom.y - worldBeforeZoom.y) * scale;
                draw();
            }

            function resetView() {
                scale = 50;
                resizeCanvas(); // Use resize to recenter everything
            }

            function handleWheel(e) {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const zoomIntensity = 1.1;
                const zoomFactor = e.deltaY < 0 ? zoomIntensity : 1 / zoomIntensity;
                applyZoom(zoomFactor, mouseX, mouseY);
            }
            
            zoomInBtn.addEventListener('click', () => applyZoom(1.5, lastMousePos.x, lastMousePos.y));
            zoomOutBtn.addEventListener('click', () => applyZoom(1 / 1.5, lastMousePos.x, lastMousePos.y));
            resetZoomBtn.addEventListener('click', resetView);

            function updateFunctions() {
                functions = [];
                const functionGroups = document.querySelectorAll('.function-input-group');
                functionGroups.forEach((group, index) => {
                    const input = group.querySelector('.function-input');
                    const derivativeBtn = group.querySelector('.derivative-btn');
                    const isInequality = /[<>]/.test(input.value);

                    // Disable derivative button for inequalities for mathematical correctness.
                    derivativeBtn.disabled = isInequality;
                    if (isInequality) {
                        derivativeBtn.classList.add('opacity-50', 'cursor-not-allowed');
                        derivativeBtn.classList.remove('active');
                    } else {
                        derivativeBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    }

                    functions.push({
                        id: index,
                        expression: input.value,
                        color: colors[index % colors.length],
                        showDerivative: !isInequality && derivativeBtn.classList.contains('active')
                    });
                });
                debouncedDraw();
            }
            
            function addFunctionInput() {
                if (document.querySelectorAll('.function-input').length >= colors.length) {
                    errorMessage.textContent = "Maximum functions reached.";
                    return;
                }
                const group = document.createElement('div');
                group.className = 'function-input-group flex items-center gap-2';
                group.innerHTML = `
                     <input type="text" class="function-input w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all">
                     <button class="derivative-btn opacity-0 text-gray-500 hover:bg-gray-200 rounded-md px-2 py-1 text-sm font-semibold transition-all" title="Plot Derivative">f'(x)</button>
                     <button class="remove-btn opacity-0 text-gray-400 hover:text-red-500 transition-opacity text-xl font-bold">&times;</button>
                `;
                functionList.appendChild(group);
                const new_input = group.querySelector('input');
                new_input.focus();
                lastFocusedInput = new_input;
            }

            function switchKeyboardTab(e) {
                if (!e.target.classList.contains('keyboard-tab')) return;
                document.querySelectorAll('.keyboard-tab').forEach(tab => tab.classList.remove('active-tab'));
                e.target.classList.add('active-tab');
                const targetPanelId = e.target.dataset.panel;
                document.querySelectorAll('.math-keyboard > div[id^="keyboard-"]').forEach(panel => {
                    panel.style.display = panel.id === targetPanelId ? 'grid' : 'none';
                });
            }

            function handleKeyboard(e) {
                if (e.target.tagName !== 'BUTTON' || !e.target.closest('.math-keyboard')) return;
                if (!lastFocusedInput) {
                    lastFocusedInput = document.querySelector('.function-input');
                    if (!lastFocusedInput) return;
                }
                
                const key = e.target.dataset.key;
                const action = e.target.dataset.action;
                const { selectionStart, selectionEnd, value } = lastFocusedInput;
                
                if (action === 'backspace') {
                    const newValue = selectionStart === selectionEnd && selectionStart > 0 
                        ? value.substring(0, selectionStart - 1) + value.substring(selectionEnd)
                        : value.substring(0, selectionStart) + value.substring(selectionEnd);
                    lastFocusedInput.value = newValue;
                    const newCursorPos = selectionStart > 0 ? selectionStart - 1 : 0;
                    lastFocusedInput.setSelectionRange(newCursorPos, newCursorPos);
                } else if (key) {
                    const newValue = value.substring(0, selectionStart) + key + value.substring(selectionEnd);
                    lastFocusedInput.value = newValue;
                    const newCursorPos = selectionStart + key.length;
                    lastFocusedInput.setSelectionRange(newCursorPos, newCursorPos);
                }
                lastFocusedInput.focus();
                updateFunctions();
            }
            
            function handleFunctionListClick(e) {
                // Handle remove button
                if (e.target.classList.contains('remove-btn')) {
                    if (document.querySelectorAll('.function-input-group').length > 1) {
                         e.target.closest('.function-input-group').remove();
                    } else {
                        e.target.closest('.function-input-group').querySelector('input').value = '';
                    }
                    updateFunctions();
                }
                
                // Handle derivative button
                if (e.target.classList.contains('derivative-btn')) {
                    e.target.classList.toggle('active');
                    updateFunctions();
                }
            }

            // --- Initialization ---
            resizeCanvas();
            lastFocusedInput = document.querySelector('.function-input');
            updateFunctions();
            
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp); 
            canvas.addEventListener('wheel', handleWheel);
            
            canvas.addEventListener('mouseenter', () => { cursorCoords.style.display = 'block'; });
            canvas.addEventListener('mouseleave', () => { cursorCoords.style.display = 'none'; });

            canvas.addEventListener('touchstart', (e) => handleMouseDown(e.touches[0]));
            canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleMouseMove(e.touches[0]); });
            canvas.addEventListener('touchend', handleMouseUp);

            functionList.addEventListener('input', updateFunctions);
            functionList.addEventListener('click', handleFunctionListClick);
            functionList.addEventListener('focusin', (e) => {
                 if(e.target.classList.contains('function-input')) lastFocusedInput = e.target;
            });

            addFunctionBtn.addEventListener('click', addFunctionInput);
            mathKeyboard.addEventListener('click', handleKeyboard);
            keyboardTabs.addEventListener('click', switchKeyboardTab);
        });
    </script>
</body>
</html>




